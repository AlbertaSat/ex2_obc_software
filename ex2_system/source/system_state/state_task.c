/*
 * Copyright (C) 2021  University of Alberta
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
/**
 * @file state_task.c
 * @author Andrew R. Rooney, Arash Yazdani
 * @date Feb. 19, 2021
 */
#include "system_state/state_task.h"

#include <os_task.h>

#include "HL_gio.h"
#include "HL_het.h"
#include "uhf.h"

static const bool Off = FALSE;
static const bool On = TRUE;

static void state_daemon(void *pvParam);

static TaskHandle_t state_daemon_handle;

/**
 * Query state from NanoAvionics EPS and make required updates
 * as-per the modes of operations.
 *
 * @param param
 *  Task parameter (not used)
 * @attention OBC is not operational in HW critical and critical states
 */
static void state_daemon(void *pvParam) {
  TickType_t state_delay = pdMS_TO_TICKS(1000);
  for (;;) {

//#ifndef EPS_IS_STUBBED
    eps_mode_e eps_batt_mode;
    sat_state_e SAT_state;
    systems_status_t subsystem_target_state = {
      .heater = Off,
      .eps = Off,
      .obc = Off,
      .uhf = Off,
      .stx = Off,
      .iris = Off,
      .dfgm = Off,
      .adcs = Off,
    };
    eps_batt_mode = get_eps_batt_mode();
    SAT_state = eps2sat_mode_cnv(eps_batt_mode);

    switch (SAT_state) {
      case hw_critical_state:  // Battery heaters on
        subsystem_target_state.heater = On;
        break;
      case critical_state:  // Battery heaters & EPS on
        subsystem_target_state.heater = On;
        subsystem_target_state.eps = On;
        break;
      case safe_state:  // Battery heaters, EPS, OBC & UHF on
        subsystem_target_state.heater = On;
        subsystem_target_state.eps = On;
        subsystem_target_state.obc = On;
        subsystem_target_state.uhf = On;
        // TODO: start a task that prepares for critical mode
        break;
      case operational_state:  // All subsystems on
        subsystem_target_state.heater = On;
        subsystem_target_state.eps = On;
        subsystem_target_state.obc = On;
        subsystem_target_state.uhf = On;
        subsystem_target_state.stx = On;
        subsystem_target_state.iris = On;
        subsystem_target_state.dfgm = On;
        subsystem_target_state.adcs = On;
        break;
      default:
        // Shouldn't happen.
        ex2_log("Unexpected Satellite mode\n");
        break;
    }

    change_systems_status(subsystem_target_state);
//#endif
//    taskYIELD();
    vTaskDelay(state_delay);
  }
}

/**
 * start the state task daemon.
 *
 * @returns status
 *  error report of creation
 */
SAT_returnState start_state_daemon() {
  if (xTaskCreate((TaskFunction_t)state_daemon, "state_task", 9600, NULL,
                  STATE_TASK_PRIO, &state_daemon_handle) != pdPASS) {
    ex2_log("FAILED TO CREATE TASK state_task\n");
    return SATR_ERROR;
  }
  ex2_log("State task started\n");
  return SATR_OK;
}

void stop_state_daemon() {
  vTaskDelete(state_daemon_handle);
}

/**
 * @brief Translates EPS mode to the satellite's operation state
 * @params batt_mode
 *  EPS battery mode
 * @attention Could become redundant if MOP changes (use batt_state directly)
 * @attention OBC will turn off if the case is critical
 * @returns satellite's status
 */
sat_state_e eps2sat_mode_cnv(eps_mode_e batt_mode) {
  sat_state_e state;
  switch (batt_mode) {
    case critical:
      state = critical_state;
      break;
    case safe:
      state = safe_state;
      break;
    case normal:
      state = operational_state;
      break;
    case full:
      state = operational_state;
      break;
    default:
      // Should not happen but the safe option is not to change anything
      ex2_log("Unexpected EPS mode\n");
      break;
  }
  return state;
}

/**
 * @brief Switches the power of each subsystem.
 * @params ctrl_word
 *  system control word generated by state machine
 * @attention The operations functions must be accessible to call from a GS
 * command too.
 * @attention May be replaced with an object
 * @returns
 */
void change_systems_status(systems_status_t subsystem_target_state) {
  power_switch_uhf(subsystem_target_state.uhf);
  power_switch_sys(STX_PWR_CHNL, subsystem_target_state.stx);
  power_switch_sys(IRIS_PWR_CHNL, subsystem_target_state.iris);
  power_switch_sys(DFGM_PWR_CHNL, subsystem_target_state.dfgm);
  power_switch_sys(ADCS_PWR_CHNL, subsystem_target_state.adcs);
  // TODO: If sys_state[i] == SYS_NO_RESPONSE, do sth.
  // e.g., refine state task delay and repeat.
}

/**
 * @brief Switches the power of UHF TRX
 * @params uhf_status
 *  The status that the UHF TRX must be (on/off)
 * @attention If EPS moves to critical state, it shuts down the power and this
 * function is unused. This function, however, allows for other tasks or a
 * scheduled command from the ground with a timer. It is preferred if it's used
 * indirectly through change_systems_status.
 * @returns uhf_status for confirmation
 */
UHF_return power_switch_uhf(const bool uhf_status) {
  UHF_return status;
  if (uhf_status == false) {
    status = HAL_UHF_lowPwr(1);
    // or if we want to shut it down completely:
    // gioSetBit(UHF_GIO_PORT, UHF_GIO_PIN, 0); // Disables the UHF transceiver
  } else {
    gioSetBit(UHF_GIO_PORT, UHF_GIO_PIN,
              1);  // Even if it was not set to zero in this function.
    uint8_t is_low_pwr;
    status = HAL_UHF_getLowPwr(&is_low_pwr);
    if (uhf_status == false) {
      if (is_low_pwr) {
        // send any command to wake it up, e.g.,
        uint8_t scw[12];
        status = HAL_UHF_getSCW(scw);
        // Here write any code based on the read scw!
      }
    }
    if (status < 0) {
      ex2_log("Switching UHF TRX's power failed.");
    }
  }
  return status;
}


sys_returnstate_e power_switch_sys(const uint8_t channel, const bool target_state) {
  int8_t current_status = eps_get_pwr_chnl(channel);
  if (current_status != target_state) {
    eps_set_pwr_chnl(channel, target_state);
    current_status = eps_get_pwr_chnl(channel);
  }
  if (current_status == target_state) {
    return (sys_returnstate_e)current_status;
  } else {
    ex2_log("Switching system power failed.");
    return SYS_NO_RESPONSE;
  }
}
