/*
 * Copyright (C) 2021  University of Alberta
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
/**
 * @file state_task.c
 * @author Andrew R. Rooney
 * @date Feb. 19, 2021
 */
#include "system_state/state_task.h"

#include <FreeRTOS.h>
#include <os_task.h>

#include "HL_gio.h"
#include "HL_het.h"
#include "uhf.h"

// TODO: Numbers to be set
#define STX_PWR_CHNL 1
#define IRIS_PWR_CHNL 1
#define DFGM_PWR_CHNL 1
#define ADCS_PWR_CHNL 1

static void state_daemon(void *pvParam);

/**
 * Query state from NanoAvionics EPS and make required updates
 * as-per the modes of operations.
 *
 * @param param
 *  Task parameter (not used)
 * @attention OBC is not operational in HW critical and critical states
 */
static void state_daemon(void *pvParam) {
  TickType_t state_delay = pdMS_TO_TICKS(1000);
  for (;;) {
    // Fig. 4 in MOP
    eps_mode_e eps_batt_mode;
    SAT_state_e SAT_state;
    uint8_t system_ctrl =
        1;  // A control word deciding what systems must be working
    // LSB -> MSB: Battery heaters, EPS, OBC, UHF, S-band, Iris, DFGM, ADCS
    eps_batt_mode = get_eps_batt_mode();
    SAT_state = eps2sat_mode_cnv(eps_batt_mode);

    switch (SAT_state) {
      case hw_critical_state:
        system_ctrl = 0b00000001;  // Battery heaters on
        break;
      case critical_state:
        system_ctrl = 0b00000011;  // Battery heaters & EPS on
        break;
      case safe_state:
        system_ctrl = 0b00001111;  // Battery heaters, EPS, OBC & UHF on
        // TODO: start a task that prepares for critical mode
        break;
      case operational_state:
        system_ctrl = 0b11111111;  // All subsystems on
        break;
      default:
        // Shouldn't happen.
        ex2_log("Unexpected Satellite mode\n");
        break;
    }
    change_systems_status(system_ctrl);
    vTaskDelay(state_delay);
  }
}

/**
 * start the state task daemon.
 *
 * @returns status
 *  error report of creation
 */
SAT_returnState start_state_daemon() {
  if (xTaskCreate((TaskFunction_t)state_daemon, "state_task", 512, NULL,
                  STATE_TASK_PRIO, NULL) != pdPASS) {
    ex2_log("FAILED TO CREATE TASK state_task\n");
    return SATR_ERROR;
  }
  ex2_log("State task started\n");
  return SATR_OK;
}

/**
 * @brief Translates EPS mode to the satellite's operation state
 * @params batt_mode
 *  EPS battery mode
 * @attention Could become redundant if MOP changes (use batt_state directly)
 * @attention OBC will turn off if the case is critical
 * @returns satellite's status
 */
SAT_state_e eps2sat_mode_cnv(eps_mode_e batt_mode) {
  SAT_state_e state;
  switch (batt_mode) {
    case critical:
      state = critical_state;
      break;
    case safe:
      state = safe_state;
      break;
    case normal:
    case full:
      state = operational_state;
      break;
    default:
      // Should not happen but the safe option is not to change anything
      ex2_log("Unexpected EPS mode\n");
      break;
  }
  return state;
}

/**
 * @brief Switches the power of each subsystem.
 * @params ctrl_word
 *  system control word generated by state machine
 * @attention The operations functions must be accessible to call from a GS
 * command too.
 * @attention May be replaced with an object
 * @returns
 */
void change_systems_status(uint8_t ctrl_word) {
  int8_t sys_state[8] = {1};
  systems_status systems_ctrl;  //* Can be made global to be accessed by HK
  systems_ctrl.EPS = (ctrl_word >> 1) & 1;
  systems_ctrl.OBC = (ctrl_word >> 2) & 1;
  systems_ctrl.UHF = (ctrl_word >> 3) & 1;
  sys_state[3] = power_switch_uhf(&systems_ctrl.UHF);
  systems_ctrl.STX = (ctrl_word >> 4) & 1;
  sys_state[4] = power_switch_stx(&systems_ctrl.STX);
  systems_ctrl.Iris = (ctrl_word >> 5) & 1;
  sys_state[5] = power_switch_iris(&systems_ctrl.Iris);
  systems_ctrl.DFGM = (ctrl_word >> 6) & 1;
  sys_state[6] = power_switch_dfgm(&systems_ctrl.DFGM);
  systems_ctrl.ADCS = (ctrl_word >> 7) & 1;
  sys_state[7] = power_switch_adcs(&systems_ctrl.ADCS);
  // TODO: If sys_state[i] == SYS_NO_RESPONSE, do sth.
  // e.g., refine state task delay and repeat.
}

/**
 * @brief Switches the power of UHF TRX
 * @params uhf_status
 *  The status that the UHF TRX must be (on/off)
 * @attention If EPS moves to critical state, it shuts down the power and this
 * function is unused. This function, however, allows for other tasks or a
 * scheduled command from the ground with a timer. It is preferred if it's used
 * indirectly through change_systems_status.
 * @returns uhf_status for confirmation
 */
SYS_returnState power_switch_uhf(bool *uhf_status) {
  int8_t status;
  if (uhf_status == false) {
    status = HAL_UHF_lowPwr(1);
    // or if we want to shut it down completely:
    // gioSetBit(hetPORT2, 22, 0); // Disables the UHF transceiver
  } else {
    gioSetBit(hetPORT2, 22,
              1);  // Even if it was not set to zero in this function.
    uint8_t is_low_pwr;
    status = HAL_UHF_getLowPwr(&is_low_pwr);
    if (uhf_status == 0) {
      if (is_low_pwr) {
        // send any command to wake it up, e.g.,
        uint8_t scw[12];
        status = HAL_UHF_getSCW(&scw);
        // Here write any code based on the read scw!
      }
    }
    if (status != 0) {
      ex2_log("Switching UHF TRX's power failed.");
      // An error occurred. Call this function again?
    }
  }
  return status;
}

/*
 * Independent functions are considered for easier modification.
 * e.g., We might need to initiate a procedure for a subsystem before
 * disconnecting power.
 * @attention: eps_get_pwr_chnl must be defined in the <eps.c>
 */
SYS_returnState power_switch_stx(bool *stx_status) {
  int8_t current_status = eps_get_pwr_chnl(STX_PWR_CHNL);
  if (current_status != *stx_status) {
    eps_set_pwr_chnl(STX_PWR_CHNL, *stx_status);
    current_status = eps_get_pwr_chnl(STX_PWR_CHNL);
  }
  if (current_status == *stx_status) {
    return (SYS_returnState)current_status;
  } else {
    ex2_log("Switching S-band transmitter's power failed.");
    return SYS_NO_RESPONSE;
  }
}

SYS_returnState power_switch_iris(bool *iris_status) {
  int8_t current_status = eps_get_pwr_chnl(IRIS_PWR_CHNL);
  if (current_status != *iris_status) {
    eps_set_pwr_chnl(IRIS_PWR_CHNL, *iris_status);
    current_status = eps_get_pwr_chnl(IRIS_PWR_CHNL);
  }
  if (current_status == *iris_status) {
    return (SYS_returnState)current_status;
  } else {
    ex2_log("Switching Iris's power failed.");
    return SYS_NO_RESPONSE;
  }
}

SYS_returnState power_switch_dfgm(bool *dfgm_status) {
  int8_t current_status = eps_get_pwr_chnl(DFGM_PWR_CHNL);
  if (current_status != *dfgm_status) {
    eps_set_pwr_chnl(DFGM_PWR_CHNL, *dfgm_status);
    current_status = eps_get_pwr_chnl(DFGM_PWR_CHNL);
  }
  if (current_status == *dfgm_status) {
    return (SYS_returnState)current_status;
  } else {
    ex2_log("Switching DFGM's power failed.");
    return SYS_NO_RESPONSE;
  }
}

SYS_returnState power_switch_adcs(bool *adcs_status) {
  int8_t current_status = eps_get_pwr_chnl(ADCS_PWR_CHNL);
  if (current_status != *adcs_status) {
    eps_set_pwr_chnl(ADCS_PWR_CHNL, *adcs_status);
    current_status = eps_get_pwr_chnl(ADCS_PWR_CHNL);
  }
  if (current_status == *adcs_status) {
    return (SYS_returnState)current_status;
  } else {
    ex2_log("Switching ADCS's power failed.");
    return SYS_NO_RESPONSE;
  }
}
